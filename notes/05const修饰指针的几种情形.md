markdown
# const 修饰指针的几种情形（C/C++ 完整版）

## 一、核心原则

- `const` 在 `*` 左边：修饰指针指向的值
- `const` 在 `*` 右边：修饰指针本身
- 两边都有：值和指针本身都不能改

## 二、指向和值的修改

- 改指向：`p = &b;`
- 改值：`*p = 20;`

## 三、三种常见情形

### 1. `const int *p` 或 `int const *p`
- 指向可改，值不可改

示例：
```cpp
int a = 10;
int b = 10;
const int *p = &a;
```

操作：

```cpp
*p = 20; // 错误
p = &b;   // 正确
```

### 2. `int * const p`

* 值可改，指向不可改

示例：

```cpp
int a = 10;
int b = 10;
int * const p = &a;
```

操作：

```cpp
*p = 20; // 正确
p = &b;   // 错误
```

### 3. `const int * const p`

* 指向不可改，值不可改

示例：

```cpp
int a = 10;
int b = 20;
const int * const p = &a;
```

操作：

```cpp
*p = 30; // 错误
p = &b;   // 错误
```

## 四、`const int *p` 和 `int const *p` 有区别吗？

* 没有区别，完全等价。
* 两者都表示指向可改，值不可改。

示例：

```cpp
const int *p;
int const *p;
```

## 五、快速记忆法

* `const int *p`: 值不可改，指向可改
* `int * const p`: 指向不可改，值可改
* `const int * const p`: 值和指向都不可改

## 六、表格总结

| 声明形式                  | `p = &b`（改指向） | `*p = 20`（改值） |
| --------------------- | ------------: | ------------: |
| `const int *p`        |             ✅ |             ❌ |
| `int * const p`       |             ❌ |             ✅ |
| `const int * const p` |             ❌ |             ❌ |

## 七、常见误区

### 误区 1：`const int *p` 表示 `a` 本身一定是常量

**错。**

它只表示：

> 不能通过 `p` 修改值

但如果原变量本身不是 `const`，仍然可以直接改：

```cpp
int a = 10;
const int *p = &a;

a = 100;   // ✅ 合法（直接改变量）
```

### 误区 2：`const` 只会修饰 `int`

**错。**

`const` 修饰谁，要看位置：

* `const int *p`：`const` 修饰 `int`（值只读）
* `int * const p`：`const` 修饰 `p`（指针只读）

### 误区 3：`const int *p` 和 `int * const p` 名字看起来差不多，含义也差不多

**错。它们正好一个锁“值”，一个锁“指向”。**

* `const int *p`：锁值，不锁指向
* `int * const p`：锁指向，不锁值

## 八、面试/考试常问

### Q1：为什么 `const int *p = &a;` 中 `a` 不是 `const` 也能赋值？

因为这是“**权限收紧**”（更安全）：

* 原本 `a` 可修改
* 现在交给 `const int *p`
* 通过 `p` 只能读，不能写

这不会破坏安全性，所以允许。

### Q2：为什么 `int *p = &x;` 不能接 `const int x` 的地址？

因为这是“**权限放宽**”（不安全）：

* `x` 本来是常量，不能改
* 如果把它地址交给普通指针 `int *p`
* 就可能通过 `*p = ...` 去修改常量

这会破坏常量约束，所以不允许。

示例（非法）：

```cpp
const int x = 10;
int *p = &x;    // ❌ 不允许
```

### Q3：函数参数里为什么经常写 `const int *p`？

因为函数只需要“读数据”，不需要“改数据”，这样写有两个好处：

1. 防止误修改（更安全）
2. 函数接口语义更清晰（调用者一看就知道不会改）

示例：

```cpp
void printValue(const int *p) {
    if (p != nullptr) {
        std::cout << *p << std::endl;
    }
}
```

## 九、进阶补充：多级指针里怎么判断

如果遇到复杂声明，不要慌，仍然按“`*` 左右看 const”来拆。

例如：

```cpp
const int *p1;          // 指向常量 int 的指针
int * const p2 = &a;    // 常量指针，指向 int
const int * const p3 = &a; // 常量指针，指向常量 int
```

先把基础三种吃透，多级指针后面再学会更轻松。

## 十、自测练习

判断下面哪些语句合法：

```cpp
int a = 10, b = 20;

const int *p1 = &a;
int * const p2 = &a;
const int * const p3 = &a;

// ① p1 = &b;      // ?
// ② *p1 = 30;     // ?
// ③ p2 = &b;      // ?
// ④ *p2 = 30;     // ?
// ⑤ p3 = &b;      // ?
// ⑥ *p3 = 30;     // ?
```

### 答案

* ① ✅（`p1` 指向可改）
* ② ❌（`p1` 不能改值）
* ③ ❌（`p2` 指向不可改）
* ④ ✅（`p2` 可以改值）
* ⑤ ❌（`p3` 指向不可改）
* ⑥ ❌（`p3` 不能改值）
