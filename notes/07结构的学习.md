# C++ 结构体（struct）学习笔记

> 适用阶段：C++ 初学  
> 主题内容：结构体基础、结构体数组、结构体指针、嵌套结构体、结构体做函数参数  
> 笔记目标：理解结构体的本质、常见用法，以及它和数组、指针、函数之间的联系

# 1. 结构体的基本概念

## 1.1 什么是结构体

在 C++ 中，**结构体（struct）是一种自定义数据类型**，它可以把多个不同类型的数据组合在一起，形成一个整体。

比如，一个学生通常有：

- 姓名
- 年龄
- 分数

这三个数据类型不一定相同，但它们都属于“学生”这个对象，所以就可以用结构体把它们组织起来。

---

## 1.2 为什么要使用结构体

如果不用结构体，我们可能要这样定义学生信息：

```cpp
string name = "张三";
int age = 18;
int score = 100;
````

如果学生多了，就会出现大量零散变量，不方便管理。

而使用结构体后，可以把这些信息打包：

```cpp
struct Student {
    string name;
    int age;
    int score;
};
```

这样 `Student` 就变成了一个新的数据类型，专门用来描述“学生”。

---

# 2. 结构体的定义与使用

## 2.1 定义结构体

### 代码示例

```cpp
#include<iostream>
using namespace std;
#include<string>

// 结构体：自定义数据类型
struct Student {
    string name;
    int age;
    int score;
};
```

---

## 2.2 结构体定义格式

```cpp
struct 结构体名 {
    成员1;
    成员2;
    成员3;
};
```

### 说明

* `struct` 是定义结构体的关键字
* `Student` 是结构体名
* 花括号中的内容叫做**成员**
* 结尾的分号 `;` **不能省略**

---

## 2.3 创建结构体变量

### 方法一：先创建，再赋值

```cpp
Student s1;
s1.name = "张三";
s1.age = 18;
s1.score = 100;
```

### 方法二：定义时初始化

```cpp
Student s2 = { "李四", 19, 98 };
```

---

## 2.4 成员访问

结构体变量通过 `.` 运算符访问成员。

### 示例

```cpp
cout << s1.name << endl;
cout << s1.age << endl;
cout << s1.score << endl;
```

### 格式

```cpp
结构体变量.成员名
```

例如：

```cpp
s1.name
s1.age
s1.score
```

---

## 2.5 基础示例完整代码

```cpp
#include<iostream>
using namespace std;
#include<string>

struct Student {
    string name;
    int age;
    int score;
};

int main() {
    Student s1;
    s1.name = "张三";
    s1.age = 18;
    s1.score = 100;

    cout << "姓名: " << s1.name << " 年龄: " << s1.age << " 分数: " << s1.score << endl;

    Student s2 = { "李四", 19, 98 };
    cout << "姓名: " << s2.name << " 年龄: " << s2.age << " 分数: " << s2.score << endl;

    return 0;
}
```

---

# 3. 结构体数组

## 3.1 什么是结构体数组

结构体数组本质上就是：

> **数组中的每一个元素，都是同一种结构体类型的变量。**

例如，一个班有多个学生，就可以定义一个学生数组。

---

## 3.2 定义结构体数组

### 示例

```cpp
Student arr[3];
```

这表示创建了一个数组，数组中有 3 个元素，每个元素的类型都是 `Student`。

也就是说：

* `arr[0]` 是一个学生
* `arr[1]` 是一个学生
* `arr[2]` 是一个学生

---

## 3.3 结构体数组初始化

### 示例

```cpp
Student arr[3] = {
    {"张三", 18, 100},
    {"李四", 19, 90},
    {"王五", 20, 80}
};
```

### 注意

初始化时的数据顺序必须与结构体成员定义顺序一致：

1. `name`
2. `age`
3. `score`

---

## 3.4 访问结构体数组中的成员

格式：

```cpp
数组名[下标].成员名
```

例如：

```cpp
arr[0].name
arr[1].age
arr[2].score
```

---

## 3.5 修改结构体数组中的数据

### 示例

```cpp
arr[2].name = "赵六";
arr[2].age = 21;
arr[2].score = 95;
```

---

## 3.6 遍历结构体数组

通常配合 `for` 循环使用。

### 示例

```cpp
for (int i = 0; i < 3; i++) {
    cout << "姓名: " << arr[i].name
         << " 年龄: " << arr[i].age
         << " 分数: " << arr[i].score << endl;
}
```

---

## 3.7 结构体数组完整示例

```cpp
#include<iostream>
using namespace std;
#include<string>

struct Student {
    string name;
    int age;
    int score;
};

int main() {
    Student students[3] = {
        {"张三", 18, 100},
        {"李四", 19, 90},
        {"王五", 20, 80}
    };

    students[2].name = "赵六";

    for (int i = 0; i < 3; i++) {
        cout << "姓名: " << students[i].name
             << " 年龄: " << students[i].age
             << " 分数: " << students[i].score << endl;
    }

    return 0;
}
```

---

## 3.8 结构体数组的意义

结构体数组适合：

* 存储多个学生信息
* 批量输出
* 查找某个学生
* 按成绩排序
* 统计平均分

它的优势是：**可以批量管理多个复杂对象。**

---

# 4. 结构体指针

## 4.1 什么是结构体指针

结构体指针本质上是一个指针变量，它存放的是**结构体变量的地址**。

例如：

```cpp
Student s1 = {"张三", 15, 100};
Student* p = &s1;
```

这里：

* `s1` 是一个结构体变量
* `&s1` 是 `s1` 的地址
* `p` 是一个指针，指向 `s1`

---

## 4.2 定义结构体指针

格式：

```cpp
结构体类型* 指针变量名;
```

例如：

```cpp
Student* p;
```

---

## 4.3 通过结构体指针访问成员

结构体指针访问成员时，不再使用 `.`，而是使用 `->`

### 示例

```cpp
p->name
p->age
p->score
```

### 为什么使用 `->`

因为 `p` 是一个指针，不是结构体变量本身。

* 结构体变量访问成员：用 `.`
* 结构体指针访问成员：用 `->`

---

## 4.4 `->` 的本质

```cpp
p->name
```

等价于：

```cpp
(*p).name
```

解释：

* `p` 是地址
* `*p` 表示根据地址找到对应的结构体变量
* `(*p).name` 表示访问该结构体变量中的 `name`

所以：

```cpp
p->name == (*p).name
```

---

## 4.5 结构体指针完整示例

```cpp
#include<iostream>
using namespace std;
#include<string>

struct Student {
    string name;
    int age;
    int score;
};

int main() {
    Student s1 = { "张三", 15, 100 };
    Student* p = &s1;

    cout << p->name << " " << p->age << " " << p->score << endl;

    return 0;
}
```

---

## 4.6 通过指针修改结构体成员

```cpp
p->name = "李四";
p->age = 18;
p->score = 95;
```

这会直接修改 `s1` 中的数据，因为 `p` 指向的就是 `s1`。

---

## 4.7 结构体指针的意义

结构体指针在后面会非常重要，常见于：

* 函数传参
* 动态内存分配
* 链表
* 树
* 图等数据结构

---

# 5. 嵌套结构体

## 5.1 什么是嵌套结构体

嵌套结构体指的是：

> **在一个结构体中，把另一个结构体作为成员。**

也就是说，结构体的成员不一定只能是 `int`、`string` 这样的基本类型，也可以是另一个结构体类型。

---

## 5.2 为什么会有嵌套结构体

现实中的很多对象都不是单层信息，而是“一个对象里面还包含另一个对象”。

例如：

* 老师包含学生信息
* 学生包含生日信息
* 订单包含地址信息
* 电脑包含 CPU 信息

这类“对象中包含对象”的关系，非常适合用嵌套结构体表示。

---

## 5.3 嵌套结构体示例

```cpp
#include<iostream>
using namespace std;
#include<string>

struct Student {
    string name;
    int age;
    int score;
};

struct Teacher {
    int id;
    string name;
    Student stu;
};

int main() {
    Teacher t1;
    t1.id = 1;
    t1.name = "王老师";

    t1.stu.name = "张三";
    t1.stu.age = 18;
    t1.stu.score = 100;

    cout << "老师编号: " << t1.id << endl;
    cout << "老师姓名: " << t1.name << endl;
    cout << "学生姓名: " << t1.stu.name << endl;
    cout << "学生年龄: " << t1.stu.age << endl;
    cout << "学生分数: " << t1.stu.score << endl;

    return 0;
}
```

---

## 5.4 嵌套结构体的访问方式

格式：

```cpp
外层变量.内层变量.成员
```

例如：

```cpp
t1.stu.name
t1.stu.age
t1.stu.score
```

---

## 5.5 嵌套结构体的本质理解

你可以把嵌套结构体理解成“组合”：

* `Teacher` 由 `id`、`name`、`Student` 组成
* `Student` 由 `name`、`age`、`score` 组成

它不是让代码更乱，而是让复杂数据更有层次。

---

## 5.6 嵌套结构体的作用

### 作用一：更真实地描述现实对象

比如老师和学生之间，就不是简单的一层关系，而是老师对象中包含学生对象。

### 作用二：数据组织更清晰

如果不用嵌套结构体，可能要这样写：

```cpp
struct Teacher {
    int id;
    string name;
    string stuName;
    int stuAge;
    int stuScore;
};
```

虽然也能实现，但学生信息被拆散了，逻辑不清楚。

如果写成：

```cpp
struct Teacher {
    int id;
    string name;
    Student stu;
};
```

一眼就知道：老师中包含一个学生对象。

### 作用三：便于复用

只要已经定义过 `Student`，以后任何地方要表示学生信息，都可以直接拿来用，不用重复定义。

---

# 6. 结构体做函数参数

## 6.1 结构体为什么可以做函数参数

结构体本质上也是一种数据类型，所以它当然可以像 `int`、`double` 一样，作为函数参数传递。

例如：

```cpp
void func(Student s)
```

或者：

```cpp
void func(Student* s)
```

---

## 6.2 结构体做函数参数的两种常见方式

* 值传递
* 地址传递

这两种方式最大的区别在于：

> 函数内部对参数的修改，是否会影响原来的实参

---

# 7. 值传递

## 7.1 什么是值传递

值传递指的是：

> 调用函数时，把实参的数据复制一份，传给形参

函数中操作的是这份副本，而不是原来的变量本身。

---

## 7.2 值传递示例

```cpp
#include<iostream>
using namespace std;
#include<string>

struct Student {
    string name;
    int age;
    int score;
};

void printStudent1(Student s) {
    s.age = 20;  // 不影响实参
    cout << "姓名: " << s.name
         << " 年龄: " << s.age
         << " 分数: " << s.score << endl;
}

int main() {
    Student s1 = { "Mike", 16, 600 };
    printStudent1(s1);

    cout << "main中的年龄: " << s1.age << endl;

    return 0;
}
```

---

## 7.3 值传递的特点

### 优点

* 不会修改原始数据
* 相对安全

### 缺点

* 会发生拷贝
* 如果结构体很大，效率会变低

---

## 7.4 值传递的本质

你可以把值传递理解成：

> 给函数一份“复印件”

函数修改的是复印件，不会影响原件。

---

# 8. 地址传递

## 8.1 什么是地址传递

地址传递指的是：

> 把实参的地址传给函数

函数通过地址可以直接找到原来的变量，因此可以直接修改原数据。

---

## 8.2 地址传递示例

```cpp
#include<iostream>
using namespace std;
#include<string>

struct Student {
    string name;
    int age;
    int score;
};

void printStudent2(Student* s) {
    s->age = 29;  // 会影响实参
    cout << "姓名: " << s->name
         << " 年龄: " << s->age
         << " 分数: " << s->score << endl;
}

int main() {
    Student s1 = { "Mike", 16, 600 };
    printStudent2(&s1);

    cout << "main中的年龄: " << s1.age << endl;

    return 0;
}
```

---

## 8.3 地址传递的特点

### 优点

* 不需要整体拷贝结构体
* 效率更高
* 可以直接修改实参

### 缺点

* 有可能不小心把原数据改掉
* 使用时要更小心

---

## 8.4 地址传递的本质

你可以把地址传递理解成：

> 直接把“原件所在的位置”告诉函数

函数找到原件后，修改的就是原件本身。

---

# 9. 值传递与地址传递对比

## 9.1 对比代码

```cpp
#include<iostream>
using namespace std;
#include<string>

struct Student {
    string name;
    int age;
    int score;
};

// 值传递
void printStudent1(Student s) {
    s.age = 20;  // 不影响实参
    cout << "值传递 -> "
         << "姓名: " << s.name
         << " 年龄: " << s.age
         << " 分数: " << s.score << endl;
}

// 地址传递
void printStudent2(Student* s) {
    s->age = 29;  // 会影响实参
    cout << "地址传递 -> "
         << "姓名: " << s->name
         << " 年龄: " << s->age
         << " 分数: " << s->score << endl;
}

int main() {
    Student s1 = { "Mike", 16, 600 };

    cout << "调用前: "
         << s1.name << " "
         << s1.age << " "
         << s1.score << endl;

    printStudent1(s1);

    cout << "值传递后: "
         << s1.name << " "
         << s1.age << " "
         << s1.score << endl;

    printStudent2(&s1);

    cout << "地址传递后: "
         << s1.name << " "
         << s1.age << " "
         << s1.score << endl;

    return 0;
}
```

---

## 9.2 核心结论

### 值传递

* 传的是副本
* 修改形参不影响实参

### 地址传递

* 传的是地址
* 修改形参指向的数据会影响实参

---

## 9.3 成员访问方式对比

### 值传递时

形参是结构体变量，所以使用 `.`

```cpp
s.name
s.age
s.score
```

### 地址传递时

形参是结构体指针，所以使用 `->`

```cpp
s->name
s->age
s->score
```

---

# 10. 结构体这一章的整体逻辑梳理

学到这里，结构体这一部分其实已经形成了一条完整的知识链：

---

## 10.1 第一步：先学会定义结构体

你需要知道：

* 什么是结构体
* 如何定义结构体
* 如何创建结构体变量
* 如何用 `.` 访问成员

---

## 10.2 第二步：学会批量管理结构体

也就是结构体数组。

你需要知道：

* 数组中的每个元素都可以是一个结构体
* 可以用 `数组名[下标].成员名` 访问
* 可以配合 `for` 循环批量处理数据

---

## 10.3 第三步：学会通过地址操作结构体

也就是结构体指针。

你需要知道：

* 指针中存的是结构体变量的地址
* 访问成员要用 `->`
* `p->name` 等价于 `(*p).name`

---

## 10.4 第四步：学会组织更复杂的数据

也就是嵌套结构体。

你需要知道：

* 结构体成员还可以是另一个结构体
* 用于表示“对象中包含对象”的关系
* 访问时需要一层一层写

---

## 10.5 第五步：学会把结构体传给函数

也就是结构体做函数参数。

你需要知道：

* 值传递：传副本
* 地址传递：传地址
* 二者是否影响原数据不同

---

# 11. 常见易错点总结

## 11.1 忘记结构体定义后面的分号

错误：

```cpp
struct Student {
    string name;
    int age;
    int score;
}
```

正确：

```cpp
struct Student {
    string name;
    int age;
    int score;
};
```

---

## 11.2 把结构体变量和结构体指针的访问方式混淆

### 结构体变量

```cpp
s1.name
```

### 结构体指针

```cpp
p->name
```

不要写错。

---

## 11.3 忘记地址传递时要传地址

如果函数参数是指针：

```cpp
void func(Student* s)
```

调用时必须传地址：

```cpp
func(&s1);
```

而不是：

```cpp
func(s1);   // 错误
```

---

## 11.4 把 `->` 和 `(*p).成员` 的关系搞混

```cpp
p->name
```

等价于：

```cpp
(*p).name
```

注意括号不能少。

---

## 11.5 嵌套结构体访问层级写错

例如：

```cpp
t1.stu.name
```

要先找到 `t1`，再找到 `stu`，最后找到 `name`。

---

# 12. 学完结构体后你应该记住的核心句子

## 12.1 关于结构体本身

> 结构体是把多个不同类型的数据组合成一个整体的自定义数据类型。

## 12.2 关于结构体数组

> 结构体数组的每一个元素，都是一个结构体变量。

## 12.3 关于结构体指针

> 结构体变量用 `.` 访问成员，结构体指针用 `->` 访问成员。

## 12.4 关于嵌套结构体

> 嵌套结构体不是更乱，而是把复杂数据分层组织起来。

## 12.5 关于函数传参

> 值传递传的是副本，地址传递传的是原对象的地址。

---

# 13. 推荐练习方向

学完这一部分后，可以继续做这些练习来巩固：

## 练习 1：输出多个学生信息

要求：

* 定义结构体数组
* 输入或初始化 3 个学生
* 输出所有学生信息

---

## 练习 2：找出最高分学生

要求：

* 定义结构体数组
* 比较每个学生的 `score`
* 输出分数最高的学生信息

---

## 练习 3：写一个函数修改学生年龄

要求：

* 定义 `Student`
* 写一个函数，通过地址传递修改学生年龄
* 在 `main` 中验证修改是否成功

---

## 练习 4：写一个老师和学生的嵌套结构体

要求：

* `Teacher` 中包含 `Student`
* 输出老师和学生完整信息

---

# 14. 总结

结构体这一章的核心，不只是“会写几个示例代码”，而是要真正理解它背后的思想：

* **结构体**：把零散数据组合成对象
* **结构体数组**：批量管理多个对象
* **结构体指针**：通过地址操作对象
* **嵌套结构体**：分层表示复杂对象
* **函数传参**：理解副本和原对象的区别

如果把这一章吃透，后面学习：

* 类与对象
* 链表
* 数据结构
* 项目中的数据建模

都会轻松很多。

---

# 15. 一句话总复盘

> **结构体的本质，是让程序能够更自然地描述现实世界中的“对象”和“对象之间的关系”。**

# 16. 结构体中 `const` 的使用场景补充

在学习结构体时，`const` 也是一个非常重要的知识点。  
它的核心作用是：

> **限制数据不能被随意修改，提高代码的安全性和可读性。**

对于结构体来说，`const` 常见的使用场景主要有以下几种：

- 修饰结构体变量
- 修饰结构体指针
- 修饰函数参数
- 与引用一起使用

---

## 16.1 为什么结构体中要使用 `const`

结构体往往用来保存一组完整的数据，例如学生信息、老师信息、订单信息等。  
这些数据在很多场景下只是需要“读取”，并不希望被修改。

如果不加限制，函数内部或者其他代码就可能误改数据。

例如：

```cpp
Student s1 = { "Mike", 18, 100 };
````

如果某个函数只是想输出 `s1` 的信息，那么它本来就不应该修改 `s1.age`、`s1.score`。
这时就可以使用 `const` 来限制。

所以，`const` 的本质就是：

> **告诉编译器：这份数据只能读，不能改。**

---

# 17. `const` 修饰结构体变量

## 17.1 基本写法

```cpp
const Student s1 = { "Mike", 18, 100 };
```

这表示 `s1` 是一个常量结构体变量。

---

## 17.2 特点

一旦结构体变量被 `const` 修饰，它的成员就不能再被修改。

例如：

```cpp
const Student s1 = { "Mike", 18, 100 };
s1.age = 20;   // 错误
```

因为 `s1` 是只读的，所以不能修改它的成员。

---

## 17.3 使用场景

适用于以下情况：

* 某个结构体对象初始化后就不希望再被改动
* 表示一份固定数据
* 防止后续代码误修改

---

## 17.4 示例代码

```cpp
#include<iostream>
#include<string>
using namespace std;

struct Student {
    string name;
    int age;
    int score;
};

int main() {
    const Student s1 = { "Mike", 18, 100 };

    cout << "姓名: " << s1.name << endl;
    cout << "年龄: " << s1.age << endl;
    cout << "分数: " << s1.score << endl;

    // s1.age = 20;   // 错误，const 修饰后不能修改

    return 0;
}
```

---

# 18. `const` 修饰结构体指针

结构体和指针结合时，`const` 的位置不同，含义也不同。
这部分是结构体中 `const` 最容易混淆的地方。

主要分三种情况：

1. **指向常量的指针**
2. **常量指针**
3. **指向常量的常量指针**

---

## 18.1 指向常量的指针

### 写法

```cpp
const Student* p;
```

或者：

```cpp
Student const* p;
```

这两种写法是一样的。

---

## 18.2 含义

这里的重点是：

> **不能通过指针 `p` 去修改它指向的结构体内容。**

但是：

* `p` 本身可以改指向
* 指向的内容不能通过 `p` 修改

---

## 18.3 示例代码

```cpp
#include<iostream>
#include<string>
using namespace std;

struct Student {
    string name;
    int age;
    int score;
};

int main() {
    Student s1 = { "Mike", 18, 100 };
    Student s2 = { "Tom", 20, 95 };

    const Student* p = &s1;

    cout << p->name << " " << p->age << " " << p->score << endl;

    // p->age = 30;   // 错误，不能通过 p 修改结构体内容

    p = &s2;          // 正确，指针本身可以改指向

    cout << p->name << " " << p->age << " " << p->score << endl;

    return 0;
}
```

---

## 18.4 记忆方法

```cpp
const Student* p;
```

可以理解为：

> `p` 指向的是“只读的 Student”

也就是：

* **内容不能改**
* **指向可以改**

---

# 19. 常量指针

## 19.1 写法

```cpp
Student* const p = &s1;
```

---

## 19.2 含义

这里的重点是：

> **指针 `p` 本身不能改指向。**

但是：

* 可以通过 `p` 修改它指向的结构体内容
* `p` 自己不能再指向别的对象

---

## 19.3 示例代码

```cpp
#include<iostream>
#include<string>
using namespace std;

struct Student {
    string name;
    int age;
    int score;
};

int main() {
    Student s1 = { "Mike", 18, 100 };
    Student s2 = { "Tom", 20, 95 };

    Student* const p = &s1;

    p->age = 30;   // 正确，可以修改指向的内容

    cout << p->name << " " << p->age << " " << p->score << endl;

    // p = &s2;    // 错误，p 是常量指针，不能改指向

    return 0;
}
```

---

## 19.4 记忆方法

```cpp
Student* const p;
```

可以理解为：

> `p` 这个指针本身是固定的

也就是：

* **指向不能改**
* **内容可以改**

---

# 20. 指向常量的常量指针

## 20.1 写法

```cpp
const Student* const p = &s1;
```

---

## 20.2 含义

这种情况限制最严格：

* 不能通过 `p` 修改结构体内容
* `p` 本身也不能改指向

也就是说：

> **内容不能改，指向也不能改。**

---

## 20.3 示例代码

```cpp
#include<iostream>
#include<string>
using namespace std;

struct Student {
    string name;
    int age;
    int score;
};

int main() {
    Student s1 = { "Mike", 18, 100 };

    const Student* const p = &s1;

    cout << p->name << " " << p->age << " " << p->score << endl;

    // p->age = 30;   // 错误，内容不能改
    // p = nullptr;   // 错误，指向不能改

    return 0;
}
```

---

## 20.4 三种指针形式总结

| 写法                       | 能否改内容 | 能否改指向 |
| ------------------------ | ----- | ----- |
| `const Student* p`       | 不可以   | 可以    |
| `Student* const p`       | 可以    | 不可以   |
| `const Student* const p` | 不可以   | 不可以   |

---

# 21. 结构体做函数参数时 `const` 的使用

这是结构体中 `const` **最常用、最重要** 的场景之一。

---

## 21.1 为什么函数参数要加 `const`

如果函数只是想读取结构体中的数据，而不想修改它，那么就应该加上 `const`。

这样做的好处有两个：

### 好处一：防止误修改数据

函数内部如果不小心写了修改代码，编译器会直接报错。

### 好处二：语义更清晰

别人一看函数参数，就知道：

> 这个函数只是读取数据，不会改原数据

---

# 22. `const` + 地址传递

## 22.1 写法

```cpp
void printStudent(const Student* s)
```

---

## 22.2 含义

表示：

* 传入的是结构体地址
* 不会拷贝整个结构体，效率较高
* 不能通过这个指针修改结构体内容

---

## 22.3 示例代码

```cpp
#include<iostream>
#include<string>
using namespace std;

struct Student {
    string name;
    int age;
    int score;
};

void printStudent(const Student* s) {
    cout << "姓名: " << s->name
         << " 年龄: " << s->age
         << " 分数: " << s->score << endl;

    // s->age = 20;   // 错误，const 限制不能修改
}

int main() {
    Student s1 = { "Mike", 18, 100 };
    printStudent(&s1);

    return 0;
}
```

---

## 22.4 为什么这种写法很常见

因为它同时兼顾了两点：

* **效率高**：不拷贝整个结构体
* **安全**：不能修改原数据

所以当结构体比较大时，如果函数只是读取数据，常写成：

```cpp
void func(const Student* s)
```

---

# 23. `const` + 引用传递

在 C++ 里，比 `const Student*` 更常见的写法其实是：

```cpp
void printStudent(const Student& s)
```

这叫做：

> **常量引用传递**

---

## 23.1 为什么推荐这种写法

因为它有三个优点：

### 优点一：不拷贝，提高效率

和地址传递一样，不会整体复制结构体。

### 优点二：不能修改原数据，更安全

加了 `const` 后，函数内部不能修改 `s`。

### 优点三：使用起来更自然

访问成员时用 `.`，不像指针那样要写 `->`。

---

## 23.2 示例代码

```cpp
#include<iostream>
#include<string>
using namespace std;

struct Student {
    string name;
    int age;
    int score;
};

void printStudent(const Student& s) {
    cout << "姓名: " << s.name
         << " 年龄: " << s.age
         << " 分数: " << s.score << endl;

    // s.age = 20;   // 错误，const 限制不能修改
}

int main() {
    Student s1 = { "Mike", 18, 100 };
    printStudent(s1);

    return 0;
}
```

---

## 23.3 为什么这是推荐写法

如果函数只是读取结构体数据，那么最推荐写成：

```cpp
void func(const Student& s)
```

因为它同时满足：

* 不拷贝
* 不修改原数据
* 语法简洁

这是 C++ 中很经典的写法。

---

# 24. 值传递、地址传递、`const` 引用传递对比

| 传递方式               | 是否拷贝 | 能否修改实参  | 访问方式 | 适用场景           |
| ------------------ | ---- | ------- | ---- | -------------- |
| `Student s`        | 会拷贝  | 不会影响实参  | `.`  | 数据小、临时处理       |
| `Student* s`       | 不拷贝  | 可以修改实参  | `->` | 需要修改原数据        |
| `const Student* s` | 不拷贝  | 不可以修改实参 | `->` | 只读、效率较高        |
| `Student& s`       | 不拷贝  | 可以修改实参  | `.`  | 需要修改原数据，写法更自然  |
| `const Student& s` | 不拷贝  | 不可以修改实参 | `.`  | **最推荐的只读传参方式** |

---

# 25. 结构体中 `const` 的典型使用场景总结

## 25.1 场景一：不希望结构体变量被修改

```cpp
const Student s1 = { "Mike", 18, 100 };
```

适合表示固定数据。

---

## 25.2 场景二：通过指针只读取结构体内容

```cpp
const Student* p = &s1;
```

适合只读访问，不允许通过指针改值。

---

## 25.3 场景三：函数只读取结构体内容，不允许修改

```cpp
void printStudent(const Student* s)
```

或者更推荐：

```cpp
void printStudent(const Student& s)
```

这是项目中非常常见的用法。

---

## 25.4 场景四：强调“这个函数不会改你的数据”

例如：

```cpp
void showInfo(const Student& s)
```

这个函数名本身就像是“显示信息”，语义上就不应该改数据。
此时加上 `const` 就非常合理。

---

# 26. 学习 `const` 时最容易混淆的点

---

## 26.1 误区一：`const` 修饰了谁，要看它离谁更近

例如：

```cpp
const Student* p;
```

这里 `const` 修饰的是 `Student`，说明不能改内容。

而：

```cpp
Student* const p = &s1;
```

这里 `const` 修饰的是 `p`，说明不能改指向。

---

## 26.2 误区二：`const` 不代表变量完全不能用

例如：

```cpp
const Student* p = &s1;
```

这并不是说 `p` 不能用，而是说：

* 可以读
* 不能通过它改值

---

## 26.3 误区三：只读函数参数最好显式写出 `const`

如果函数逻辑上只是输出信息、查看信息、统计信息，那么最好主动加 `const`，而不是默认省略。

这样代码会更规范。

---

# 27. 适合直接记住的结论

## 27.1 关于结构体变量

> `const` 修饰结构体变量后，该结构体对象及其成员都不能被修改。

---

## 27.2 关于结构体指针

> `const Student* p`：不能通过 `p` 修改内容，但可以改指向。
> `Student* const p`：可以通过 `p` 修改内容，但不能改指向。
> `const Student* const p`：内容和指向都不能改。

---

## 27.3 关于函数传参

> 如果函数只是读取结构体内容，推荐使用 `const Student& s`。
> 如果函数需要修改结构体内容，可以使用 `Student& s` 或 `Student* s`。

---

# 28. 推荐补充到脑中的一句话

> **`const` 的作用不是让代码更麻烦，而是让“谁能改、谁不能改”这件事变得更清楚。**

对于结构体来说，这一点尤其重要。
因为结构体往往表示的是一整组相关数据，一旦被误改，影响会比普通变量更大。

---

# 29. 最终总结

结构体中的 `const` 主要解决的是两个问题：

1. **保护数据，防止误修改**
2. **明确函数和指针的使用意图**

你可以把它理解为给结构体加了一层“只读保护”。

在实际开发中，尤其是函数参数设计时，`const` 非常常见。
其中最值得优先记住的写法是：

```cpp
void func(const Student& s)
```

因为它兼顾了：

* 不拷贝
* 不修改
* 写法简洁
* 可读性好

这是一种非常标准、非常推荐的 C++ 写法。

```
```

